/*
 * CrowdStrike API Specification
 *
 * Use this API specification as a reference for the API endpoints you can use to interact with your Falcon environment. These endpoints support authentication via OAuth2 and interact with detections and network containment. For detailed usage guides and examples, see our [documentation inside the Falcon console](https://falcon.crowdstrike.com/support/documentation).     To use the APIs described below, combine the base URL with the path shown for each API endpoint. For commercial cloud customers, your base URL is `https://api.crowdstrike.com`.    Each API endpoint requires authorization via an OAuth2 token. Your first API request should retrieve an OAuth2 token using the `oauth2/token` endpoint, such as `https://api.crowdstrike.com/oauth2/token`. For subsequent requests, include the OAuth2 token in an HTTP authorization header. Tokens expire after 30 minutes, after which you should make a new token request to continue making API requests.
 *
 * The version of the OpenAPI document: 2025-09-19T00:00:03Z
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`aggregate_notifications_exposed_data_records_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AggregateNotificationsExposedDataRecordsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`aggregate_notifications_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AggregateNotificationsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_actions_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateActionsV1Error {
    Status400(models::MsaspecResponseFields),
    Status401(models::MsaspecResponseFields),
    Status403(models::MsaspecResponseFields),
    Status404(models::MsaspecResponseFields),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::MsaspecResponseFields),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_export_jobs_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateExportJobsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status404(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_rules_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRulesV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_action_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteActionV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_export_jobs_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteExportJobsV1Error {
    Status400(models::MsaspecResponseFields),
    Status401(models::MsaspecResponseFields),
    Status403(models::MsaspecResponseFields),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::MsaspecResponseFields),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_notifications_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteNotificationsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_rules_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRulesV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_actions_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActionsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_export_jobs_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExportJobsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_content_for_export_jobs_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileContentForExportJobsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications_detailed_translated_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsDetailedTranslatedV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications_detailed_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsDetailedV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications_exposed_data_records_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsExposedDataRecordsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications_translated_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsTranslatedV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_notifications_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNotificationsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rules_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRulesV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`preview_rule_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PreviewRuleV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_actions_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryActionsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_notifications_exposed_data_records_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryNotificationsExposedDataRecordsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_notifications_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryNotificationsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_rules_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryRulesV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_action_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateActionV1Error {
    Status400(models::MsaspecResponseFields),
    Status401(models::MsaspecResponseFields),
    Status403(models::MsaspecResponseFields),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::MsaspecResponseFields),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_notifications_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateNotificationsV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_rules_v1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRulesV1Error {
    Status400(models::DomainErrorsOnly),
    Status401(models::DomainErrorsOnly),
    Status403(models::DomainErrorsOnly),
    Status429(models::MsaReplyMetaOnly),
    Status500(models::DomainErrorsOnly),
    UnknownValue(serde_json::Value),
}


pub async fn aggregate_notifications_exposed_data_records_v1(configuration: &configuration::Configuration, body: Vec<models::MsaAggregateQueryRequest>) -> Result<models::DomainAggregatesResponse, Error<AggregateNotificationsExposedDataRecordsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/aggregates/notifications-exposed-data-records/GET/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainAggregatesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainAggregatesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AggregateNotificationsExposedDataRecordsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn aggregate_notifications_v1(configuration: &configuration::Configuration, body: Vec<models::MsaAggregateQueryRequest>) -> Result<models::DomainAggregatesResponse, Error<AggregateNotificationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/aggregates/notifications/GET/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainAggregatesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainAggregatesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AggregateNotificationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_actions_v1(configuration: &configuration::Configuration, body: models::DomainRegisterActionsRequest) -> Result<models::DomainActionEntitiesResponseV1, Error<CreateActionsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/entities/actions/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainActionEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainActionEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateActionsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_export_jobs_v1(configuration: &configuration::Configuration, body: Vec<models::DomainLaunchExportJobRequestV1>) -> Result<models::DomainLaunchExportJobResponseV1, Error<CreateExportJobsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/entities/exports/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainLaunchExportJobResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainLaunchExportJobResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateExportJobsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_rules_v1(configuration: &configuration::Configuration, body: Vec<models::SadomainCreateRuleRequestV1>) -> Result<models::DomainRulesEntitiesResponseV1, Error<CreateRulesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/entities/rules/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainRulesEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainRulesEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRulesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_action_v1(configuration: &configuration::Configuration, id: &str) -> Result<models::DomainQueryResponse, Error<DeleteActionV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_id = id;

    let uri_str = format!("{}/recon/entities/actions/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("id", &p_query_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteActionV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_export_jobs_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainExportJobIdResponseV1, Error<DeleteExportJobsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/exports/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainExportJobIdResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainExportJobIdResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteExportJobsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_notifications_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainNotificationIdResponse, Error<DeleteNotificationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/notifications/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainNotificationIdResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainNotificationIdResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteNotificationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_rules_v1(configuration: &configuration::Configuration, ids: Vec<String>, notifications_deletion_requested: Option<bool>) -> Result<models::DomainRuleQueryResponseV1, Error<DeleteRulesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;
    let p_query_notifications_deletion_requested = notifications_deletion_requested;

    let uri_str = format!("{}/recon/entities/rules/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = p_query_notifications_deletion_requested {
        req_builder = req_builder.query(&[("notificationsDeletionRequested", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainRuleQueryResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainRuleQueryResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRulesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_actions_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainActionEntitiesResponseV1, Error<GetActionsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/actions/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainActionEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainActionEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetActionsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_export_jobs_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainExportJobEntitiesResponseV1, Error<GetExportJobsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/exports/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainExportJobEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainExportJobEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExportJobsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_file_content_for_export_jobs_v1(configuration: &configuration::Configuration, id: &str) -> Result<Vec<i32>, Error<GetFileContentForExportJobsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_id = id;

    let uri_str = format!("{}/recon/entities/export-files/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_query_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileContentForExportJobsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get detailed notifications based on their IDs. These include the translated raw intelligence content that generated the match or part of it. This API endpoint will return translated notification content. The only target language available is English. A single notification can be translated per request. In case the item's content is only partial, a URL is provided under the resource's 'details.full_content_url' path, but the content available at this URL will be the original one. 
pub async fn get_notifications_detailed_translated_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainNotificationDetailsResponseV1, Error<GetNotificationsDetailedTranslatedV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/notifications-detailed-translated/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainNotificationDetailsResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainNotificationDetailsResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationsDetailedTranslatedV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get detailed notifications based on their IDs. These include the raw intelligence content that generated the match or part of it. In case the content is only partial, a URL is provided under the resource's 'details.full_content_url' path. When present, use this URL to retrieve the full raw text content of the item. Please note this URL has a limited TTL. To get a fresh valid one, perform a new call to this API endpoint. 
pub async fn get_notifications_detailed_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainNotificationDetailsResponseV1, Error<GetNotificationsDetailedV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/notifications-detailed/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainNotificationDetailsResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainNotificationDetailsResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationsDetailedV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_notifications_exposed_data_records_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::ApiNotificationExposedDataRecordEntitiesResponseV1, Error<GetNotificationsExposedDataRecordsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/notifications-exposed-data-records/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiNotificationExposedDataRecordEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiNotificationExposedDataRecordEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationsExposedDataRecordsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_notifications_translated_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainNotificationEntitiesResponseV1, Error<GetNotificationsTranslatedV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/notifications-translated/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainNotificationEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainNotificationEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationsTranslatedV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_notifications_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainNotificationEntitiesResponseV1, Error<GetNotificationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/notifications/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainNotificationEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainNotificationEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNotificationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_rules_v1(configuration: &configuration::Configuration, ids: Vec<String>) -> Result<models::DomainRulesEntitiesResponseV1, Error<GetRulesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ids = ids;

    let uri_str = format!("{}/recon/entities/rules/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&p_query_ids.into_iter().map(|p| ("ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("ids", &p_query_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainRulesEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainRulesEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRulesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn preview_rule_v1(configuration: &configuration::Configuration, body: models::DomainRulePreviewRequest) -> Result<models::DomainAggregatesResponse, Error<PreviewRuleV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/aggregates/rules-preview/GET/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainAggregatesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainAggregatesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PreviewRuleV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_actions_v1(configuration: &configuration::Configuration, offset: Option<i32>, limit: Option<i32>, sort: Option<&str>, filter: Option<&str>, q: Option<&str>) -> Result<models::DomainQueryResponse, Error<QueryActionsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_offset = offset;
    let p_query_limit = limit;
    let p_query_sort = sort;
    let p_query_filter = filter;
    let p_query_q = q;

    let uri_str = format!("{}/recon/queries/actions/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryActionsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_notifications_exposed_data_records_v1(configuration: &configuration::Configuration, offset: Option<i32>, limit: Option<i32>, sort: Option<&str>, filter: Option<&str>, q: Option<&str>) -> Result<models::DomainQueryResponse, Error<QueryNotificationsExposedDataRecordsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_offset = offset;
    let p_query_limit = limit;
    let p_query_sort = sort;
    let p_query_filter = filter;
    let p_query_q = q;

    let uri_str = format!("{}/recon/queries/notifications-exposed-data-records/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryNotificationsExposedDataRecordsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_notifications_v1(configuration: &configuration::Configuration, offset: Option<i32>, limit: Option<i32>, sort: Option<&str>, filter: Option<&str>, q: Option<&str>) -> Result<models::DomainQueryResponse, Error<QueryNotificationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_offset = offset;
    let p_query_limit = limit;
    let p_query_sort = sort;
    let p_query_filter = filter;
    let p_query_q = q;

    let uri_str = format!("{}/recon/queries/notifications/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryNotificationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_rules_v1(configuration: &configuration::Configuration, offset: Option<i32>, limit: Option<i32>, sort: Option<&str>, filter: Option<&str>, q: Option<&str>, secondary_sort: Option<&str>) -> Result<models::DomainRuleQueryResponseV1, Error<QueryRulesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_offset = offset;
    let p_query_limit = limit;
    let p_query_sort = sort;
    let p_query_filter = filter;
    let p_query_q = q;
    let p_query_secondary_sort = secondary_sort;

    let uri_str = format!("{}/recon/queries/rules/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_secondary_sort {
        req_builder = req_builder.query(&[("secondarySort", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainRuleQueryResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainRuleQueryResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryRulesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_action_v1(configuration: &configuration::Configuration, body: models::DomainUpdateActionRequest) -> Result<models::DomainActionEntitiesResponseV1, Error<UpdateActionV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/entities/actions/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainActionEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainActionEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateActionV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_notifications_v1(configuration: &configuration::Configuration, body: Vec<models::DomainUpdateNotificationRequestV1>) -> Result<models::DomainNotificationEntitiesResponseV1, Error<UpdateNotificationsV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/entities/notifications/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainNotificationEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainNotificationEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateNotificationsV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_rules_v1(configuration: &configuration::Configuration, body: Vec<models::DomainUpdateRuleRequestV1>) -> Result<models::DomainRulesEntitiesResponseV1, Error<UpdateRulesV1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;

    let uri_str = format!("{}/recon/entities/rules/v1", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainRulesEntitiesResponseV1`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainRulesEntitiesResponseV1`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRulesV1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

